{% extends "base.html" %}

{% block title %}AutoKanban — Проекты{% endblock %}

{% block content %}
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h1 class="h3 mb-0">{{ current_project_name or "Проекты" }}</h1>
  </div>

  <div id="kanban-root">
    {% include "partials/kanban.html" %}
  </div>
  <script
    src="https://cdn.socket.io/4.7.5/socket.io.min.js"
    crossorigin="anonymous"
  ></script>
  <script>
    const kanbanRoot = document.getElementById("kanban-root");
    const DEFAULT_MESSAGE_HEIGHT = 140;
    const scrollMessagesToBottom = (container) => {
      const containers = container
        ? [container]
        : Array.from(kanbanRoot.querySelectorAll(".js-messages-scroll"));
      containers.forEach((item) => {
        item.scrollTop = item.scrollHeight;
      });
    };
    const adjustMessagesHeights = (container) => {
      const containers = container
        ? [container]
        : Array.from(kanbanRoot.querySelectorAll(".js-messages-scroll"));
      containers.forEach((item) => {
        const baseHeight = Number(item.dataset.baseHeight) || DEFAULT_MESSAGE_HEIGHT;
        const lastMessage = item.querySelector(".js-message:last-of-type");
        let targetHeight = baseHeight;
        if (lastMessage) {
          const styles = window.getComputedStyle(item);
          const paddingTop = parseFloat(styles.paddingTop) || 0;
          const paddingBottom = parseFloat(styles.paddingBottom) || 0;
          const lastHeight = Math.ceil(lastMessage.getBoundingClientRect().height);
          targetHeight = Math.max(baseHeight, lastHeight + paddingTop + paddingBottom);
        }
        item.style.height = `${targetHeight}px`;
      });
    };
    const removeFreeAgentBadge = (statusId, agentName) => {
      if (!statusId || !agentName) {
        return;
      }
      const container = kanbanRoot.querySelector(
        `.js-free-agents[data-status-id="${statusId}"]`
      );
      if (!container) {
        return;
      }
      container.querySelectorAll(".js-free-agent").forEach((badge) => {
        if (badge.dataset.agentName === agentName) {
          badge.remove();
        }
      });
    };
    const addFreeAgentBadge = (statusId, agentName, color) => {
      if (!statusId || !agentName) {
        return;
      }
      const statusTasks = kanbanRoot.querySelector(
        `.js-status-tasks[data-status-id="${statusId}"]`
      );
      if (!statusTasks) {
        return;
      }
      const columnCard = statusTasks.closest(".card");
      if (!columnCard) {
        return;
      }
      const header = columnCard.querySelector(".card-header");
      if (!header) {
        return;
      }
      let container = header.querySelector(
        `.js-free-agents[data-status-id="${statusId}"]`
      );
      if (!container) {
        container = document.createElement("div");
        container.className = "d-flex flex-wrap gap-2 mt-2 js-free-agents";
        container.dataset.statusId = statusId;
        header.appendChild(container);
      }
      const existing = container.querySelector(
        `.js-free-agent[data-agent-name="${agentName}"]`
      );
      if (existing) {
        return;
      }
      const badge = document.createElement("span");
      badge.className = "badge js-free-agent";
      badge.dataset.agentName = agentName;
      badge.style.backgroundColor = color || "#6c757d";
      badge.style.fontSize = "0.7rem";
      badge.textContent = agentName;
      container.appendChild(badge);
    };
    const updateTaskMessages = async (taskId, statusId = null) => {
      const response = await fetch(`/tasks/${taskId}/messages`);
      if (!response.ok) {
        return;
      }
      const payload = await response.json();
      const card = kanbanRoot.querySelector(`[data-task-id="${taskId}"]`);
      if (!card || payload.error) {
        return;
      }
      const header = card.querySelector(".js-task-header");
      if (header) {
        header.querySelectorAll(".js-task-agent").forEach((item) => item.remove());
        if (payload.agent_name) {
          const agentBadge = document.createElement("span");
          agentBadge.className = "badge js-task-agent";
          agentBadge.style.backgroundColor = payload.agent_color || "#6c757d";
          agentBadge.style.fontSize = "0.7rem";
          agentBadge.dataset.agentName = payload.agent_name;
          agentBadge.textContent = payload.agent_name;
          const wrapper = document.createElement("div");
          wrapper.className = "js-task-agent";
          wrapper.appendChild(agentBadge);
          header.appendChild(wrapper);
        }
      }
      const messagesContainer = card.querySelector(".js-messages-scroll");
      const messageCount = card.querySelector(".js-message-count");
      const authorCount = card.querySelector(".js-author-count");
      if (messagesContainer && payload.messages_html !== undefined) {
        messagesContainer.innerHTML = payload.messages_html;
        requestAnimationFrame(() => {
          adjustMessagesHeights(messagesContainer);
          scrollMessagesToBottom(messagesContainer);
        });
      }
      if (messageCount && payload.message_count !== undefined) {
        messageCount.textContent = payload.message_count;
      }
      if (authorCount && payload.author_count !== undefined) {
        authorCount.textContent = payload.author_count;
      }
      if (!messagesContainer) {
        adjustMessagesHeights();
        scrollMessagesToBottom();
      }
      if (payload.agent_name) {
        const targetStatusId = statusId || card?.dataset?.statusId;
        removeFreeAgentBadge(targetStatusId, payload.agent_name);
      }
    };
    const moveTaskCard = (taskId, statusId) => {
      const card = kanbanRoot.querySelector(`[data-task-id="${taskId}"]`);
      const target = kanbanRoot.querySelector(
        `.js-status-tasks[data-status-id="${statusId}"]`
      );
      if (!card || !target) {
        return;
      }
      if (card.parentElement === target) {
        return;
      }
      target.appendChild(card);
      card.dataset.statusId = statusId;
      adjustMessagesHeights(card.querySelector(".js-messages-scroll"));
    };
    const setTaskSpinner = (taskId, isActive) => {
      const card = kanbanRoot.querySelector(`[data-task-id="${taskId}"]`);
      if (!card) {
        return;
      }
      const spinner = card.querySelector(".js-llm-spinner");
      if (!spinner) {
        return;
      }
      spinner.classList.toggle("d-none", !isActive);
    };
    const updateTaskStatus = async (taskId, statusId) => {
      const response = await fetch(`/tasks/${taskId}/status`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ status_id: statusId }),
      });
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload.error || "Ошибка обновления статуса.");
      }
    };
    const handleDragStart = (event) => {
      const card = event.target.closest(".js-task-card");
      if (!card || !event.dataTransfer) {
        return;
      }
      event.dataTransfer.setData("text/plain", card.dataset.taskId);
      event.dataTransfer.effectAllowed = "move";
      setTimeout(() => {
        card.classList.add("is-dragging");
      }, 0);
    };
    const handleDrop = async (event) => {
      event.preventDefault();
      const target = event.target.closest(".js-status-tasks");
      if (!target) {
        return;
      }
      const statusId = target.dataset.statusId;
      const taskId = event.dataTransfer?.getData("text/plain");
      if (!taskId || !statusId) {
        return;
      }
      const card = kanbanRoot.querySelector(`[data-task-id="${taskId}"]`);
      const previousStatusId = card?.dataset?.statusId;
      moveTaskCard(taskId, statusId);
      try {
        await updateTaskStatus(taskId, statusId);
      } catch (error) {
        if (previousStatusId) {
          moveTaskCard(taskId, previousStatusId);
        }
        alert(error.message || "Не удалось обновить статус.");
      } finally {
        if (card) {
          card.classList.remove("is-dragging");
        }
      }
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      event.dataTransfer.dropEffect = "move";
    };
    if (window.io) {
      const socket = window.io();
      socket.on("task_status_changed", (payload) => {
        if (!payload) {
          return;
        }
        updateTaskMessages(payload.task_id, payload.status_id).finally(() => {
          moveTaskCard(payload.task_id, payload.status_id);
        });
      });
      socket.on("task_llm_started", (payload) => {
        if (!payload) {
          return;
        }
        setTaskSpinner(payload.task_id, true);
      });
      socket.on("task_llm_finished", (payload) => {
        if (!payload) {
          return;
        }
        setTaskSpinner(payload.task_id, false);
        addFreeAgentBadge(
          payload.working_status_id,
          payload.agent_name,
          payload.working_status_color
        );
      });
    }
    const initialScroll = () => {
      adjustMessagesHeights();
      requestAnimationFrame(() => scrollMessagesToBottom());
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initialScroll);
    } else {
      initialScroll();
    }
    const clearDragOver = () => {
      kanbanRoot.querySelectorAll(".js-status-tasks.drag-over").forEach((item) => {
        item.classList.remove("drag-over");
      });
    };
    kanbanRoot.addEventListener("dragstart", handleDragStart);
    kanbanRoot.addEventListener("dragend", (event) => {
      const card = event.target.closest(".js-task-card");
      if (card) {
        card.classList.remove("is-dragging");
      }
      clearDragOver();
    });
    kanbanRoot.addEventListener("dragover", (event) => {
      const target = event.target.closest(".js-status-tasks");
      if (!target) {
        return;
      }
      handleDragOver(event);
      clearDragOver();
      target.classList.add("drag-over");
    });
    kanbanRoot.addEventListener("dragleave", (event) => {
      const target = event.target.closest(".js-status-tasks");
      if (!target) {
        return;
      }
      target.classList.remove("drag-over");
    });
    kanbanRoot.addEventListener("drop", (event) => {
      const target = event.target.closest(".js-status-tasks");
      if (!target) {
        return;
      }
      target.classList.remove("drag-over");
      handleDrop(event);
    });
  </script>
  <style>
    .js-status-tasks.drag-over {
      outline: 2px dashed #adb5bd;
      outline-offset: 4px;
    }
    .js-task-card.is-dragging {
      opacity: 0;
    }
  </style>
{% endblock %}
